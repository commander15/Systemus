#include "data.h"
#include "data_p.h"

#include <QtSql/qsqldatabase.h>
#include <QtSql/qsqlquery.h>
#include <QtSql/qsqlrecord.h>
#include <QtSql/qsqlfield.h>
#include <QtSql/qsqldriver.h>

#include <QtCore/qmetaobject.h>

namespace Systemus {

Data::Data() :
    d_ptr(new DataPrivate(this))
{
}

Data::Data(const Data &other) :
    d_ptr(other.d_ptr)
{
}

Data::Data(const Data &other) :
    d_ptr(other.d_ptr)
{
}

Data::Data &operator=(const Data &other)
{
    if (this != &other)
        d_ptr = other.d_ptr;
    return *this;
}

Data::Data &operator=(const Data &&other)
{
    if (this != &other)
        d_ptr = other.d_ptr;
    return *this;
}

int Data::id() const
{
    Q_D(const Data);
    return d->id;
}

void Data::setId(int id)
{
    Q_D(Data);
    d->id = id;
}

void Data::clear()
{
    Q_D(Data);
    d->clear();
}

bool Data::get(const QString &filter)
{
    const QString request = selectStatement() + " WHERE " + filter + " LIMIT 1";
    
    QSqlQuery query;
    if (query.exec(request) && query.next()) {
        extractRecord(query.record());
        return true;
    } else {
        d->lastError = query.lastError();
        return false;
    }
}

bool Data::save()
{
    Q_D(Data);
    
    if (d->id == 0)
        return insert();
    else
        return update();
}

bool Data::insert()
{
    const QString request = insertStatement();
    
    QSqlQuery query;
    query.prepare(request);
    bindQueryValues(&query, false);
    
    if (query.exec()) {
        d->id = query.lastInsertId().toInt();
        return true;
    } else {
        d->lastError = query.lastError();
        return false;
    }
}

bool Data::update()
{
    const QString request = updateStatement();
    
    QSqlQuery query;
    query.prepare(request);
    bindQueryValues(&query, true);
    
    if (query.exec()) {
        return true;
    } else {
        d->lastError = query.lastError();
        return false;
    }
}

bool Data::deleteData()
{
    Q_D(Data);
        
    const QString request = deleteStatement() + " WHERE id = " + QString::number(d->id);
    
    QSqlQuery query;    
    if (query.exec(request)) {
        d->id = 0;
        return true;
    } else {
        d->lastError = query.lastError();
        return false;
    }
}

QSqlError Data::lastError() const
{
    Q_D(const Data);
    return d->lastError;
}

QString Data::tableName()
{
    return QString(staticMetaObject->className()) + 's';
}

QStringList Data::fieldNames(bool includeId = true, bool readable, bool writable) const
{
    QStringList fields;
    
    for (int i(includeId ? 0 : 1); i < metaObject->propertyCount(); ++i) {
        QMetaProperty property = metaObject->property(i);
        if (property.isUser() && ((readable && property.isReadable()) || (writable && property.isWritable())))
            fields.append(property.name());
    }
    
    return fields;
}

QString Data::foreignFieldName() const
{
    return QString(metaObject()->className()).toLowerCase() + "_id";
}

QSqlRecord Data::toSqlRecord() const
{
    QSqlRecord record = createRecord(AnyIntent);
    fillRecord(&record);
    return record;
}

QSqlRecord Data::createRecord(bool includeTable, PropertyIntent intent) const
{
    QSqlRecord record;

    for (int i(0); i < staticMetaObject.propertyCount(); ++i) {
        QMetaProperty property = staticMetaObject.property(i);
    }

    return record;
}

QSqlField Data::createField(const QMetaProperty &property, bool includeTable) const
{
    QSqlField field(property.name(), property.typeId());

    if (includeTable)
        field.setTableName(tableName());

    if (property.isRequired())
        field.setRequired(true);

    return field;
}

void Data::fillRecord(QSqlRecord *record)
{
    const QList<QMetaProperty> properties = usableProperties(AnyIntent);
    for (const QMetaProperty &property : properties)
        if (record->contains(property.name()))
            record->setValue(property.name(), property.readOnGadget(this));
}

void Data::extractRecord(const QSqlRecord &record)
{
    const QList<QMetaProperty> properties = usableProperties(AnyIntent);
    for (const QMetaProperty &property : properties)
        if (record.contains(property.name()))
            property.writeOnGadget(this, record.value(property.name()));
}

QString Data::selectStatement() const
{
    return driver()->sqlStatement(QSqlDriver::SelectStatement, tableName(), createRecord(), false);
}

QString Data::insertStatement() const
{
    return driver()->sqlStatement(QSqlDriver::InsertStatement, tableName(), toSqlRecord(), true);
}

QString Data::updateStatement() const
{
    return driver()->sqlStatement(QSqlDriver::UpdateStatement, tableName(), toSqlRecord(), true);
}

QString Data::deleteStatement() const
{
    return driver()->sqlStatement(QSqlDriver::DeleteStatement, tableName(), QSqlRecord(), false);
}

void Data::bindValues(QSqlQuery *query, PropertyIntent intent) const
{
    const QList<QMetaProperty> properties = usableProperties();
    for (const QMetaProperty &property : properties) {
        switch (intent) {
        case SelectIntent:
        case UpdateIntent:
            query->bindValue(':' + QString(property.name()), property.readOnGadget(this));
            break;

        case InsertIntent:
            if (property.propertyIndex() > 0)
                query->bindValue(':' + QString(property.name()), property.readOnGadget(this));
            break;

        case DeleteIntent:
            if (property.propertyIndex() == 0)
                query->bindValue(':' + QString(property.name()), property.readOnGadget(this));
            break;

        default:
            break;
        }
    }

    Q_UNUSED(includeId);
}

QList<QMetaProperty> Data::usableProperties(PropertyIntent intent)
{
    QList<QMetaProperty> properties;
    for (int i(0); i < staticMetaObject.propertyCount().size(); ++i) {
        QMetaProperty property = staticMetaObject.property(i);
        if (!property.isStored() || !property.isReadable())
            continue;

        switch (intent) {
        case SelectIntent:
            properties.append(property);
            break;

        case InsertIntent:
            if (i > 0 && property.isWritable())
                properties.append(property);
            break;

        case UpdateIntent:
            if (property.isWritable())
                properties.append(property);
            break;

        case DeleteIntent:
            if (i == 0)
                properties.append(property);
            break;

        default:
            properties.append(property);
        }
    }
    return properties;
}

}
